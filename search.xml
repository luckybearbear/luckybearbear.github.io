<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[YApi可视化接口管理平台centos7部署]]></title>
    <url>%2F2020%2F07%2F24%2FYApi%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0centos7%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[YApi 可视化接口管理平台centos7部署安装nodejs下载1wget https://npm.taobao.org/mirrors/node/v12.4.0/node-v12.4.0-linux-x64.tar.xz 解压1tar -xvf node-v12.4.0-linux-x64.tar.xz 进入bin目录，执行ls命令1cd node-v12.4.0-linux-x64/bin &amp;&amp; ls 测试1./node -v 安装成功，这是node 和 npm还不能全局使用，需要做关联。 关联12ln -s /node-v12.4.0-linux-x64/bin/node /usr/local/bin/nodeln -s /node-v12.4.0-linux-x64/bin/npm /usr/local/bin/npm 这样就可以在任何目录下执行 node 和 npm 命令。 安装MongoDB下载wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.8.tgz 解压与转移1tar -zxvf mongodb-linux-x86_64-rhel70-4.2.8.tgz 1mv mongodb-linux-x86_64-rhel70-4.2.8 /usr/local/mongodb 配置conf与目录进入mongodb目录1cd /usr/local/mongodb/ 创建db目录和日志文件12345mkdir -p ./data/dbmkdir -p ./logstouch ./logs/mongodb.log 创建mongodb.conf文件vim mongodb.conf 123456789101112#端口号port=27017#db目录dbpath=/usr/local/mongodb/data/db#日志目录logpath=//usr/local/mongodb/logs/mongodb.log#后台fork=true#日志输出logappend=true#允许远程IP连接bind_ip=0.0.0.0 启动1./bin/mongod --config mongodb.conf 连接1./bin/mongo 安装git1yum -y install git 安装YApi参考官网]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot+shiro整合]]></title>
    <url>%2F2019%2F12%2F18%2FspringbootAndShiro%2F</url>
    <content type="text"><![CDATA[依赖包12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 数据库表用户表 system_user1234567891011121314151617181920CREATE TABLE `system_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键id&apos;, `user_name` varchar(100) DEFAULT NULL COMMENT &apos;登录账号&apos;, `real_name` varchar(100) DEFAULT NULL COMMENT &apos;真实姓名&apos;, `password` varchar(255) DEFAULT NULL COMMENT &apos;密码&apos;, `salt` varchar(45) DEFAULT NULL COMMENT &apos;md5密码盐&apos;, `avatar` varchar(255) DEFAULT NULL COMMENT &apos;头像&apos;, `birthday` datetime DEFAULT NULL COMMENT &apos;生日&apos;, `sex` int(11) DEFAULT NULL COMMENT &apos;性别（1：男 2：女）&apos;, `email` varchar(45) DEFAULT NULL COMMENT &apos;电子邮件&apos;, `phone` varchar(45) DEFAULT NULL COMMENT &apos;电话&apos;, `status` int(2) DEFAULT NULL COMMENT &apos;状态(1：正常 2：冻结 ）&apos;, `del_flag` varchar(1) DEFAULT NULL COMMENT &apos;删除状态（0，正常，1已删除）&apos;, `activiti_sync` varchar(6) DEFAULT NULL COMMENT &apos;同步工作流引擎1同步0不同步&apos;, `create_by` varchar(32) DEFAULT NULL COMMENT &apos;创建人&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;创建时间&apos;, `update_by` varchar(32) DEFAULT NULL COMMENT &apos;更新人&apos;, `update_time` datetime DEFAULT NULL COMMENT &apos;更新时间&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC; 角色表 system_role123456789101112CREATE TABLE `system_role` ( `id` varchar(32) NOT NULL COMMENT &apos;主键id&apos;, `role_name` varchar(200) DEFAULT NULL COMMENT &apos;角色名称&apos;, `role_code` varchar(100) NOT NULL COMMENT &apos;角色编码&apos;, `description` varchar(255) DEFAULT NULL COMMENT &apos;描述&apos;, `create_by` varchar(32) DEFAULT NULL COMMENT &apos;创建人&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;创建时间&apos;, `update_by` varchar(32) DEFAULT NULL COMMENT &apos;更新人&apos;, `update_time` datetime DEFAULT NULL COMMENT &apos;更新时间&apos;, PRIMARY KEY (`id`), UNIQUE KEY `index_role_code` (`role_code`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC; 用户角色表 system_user_role123456789CREATE TABLE `system_user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键id&apos;, `user_id` varchar(32) DEFAULT NULL COMMENT &apos;用户id&apos;, `role_id` varchar(32) DEFAULT NULL COMMENT &apos;角色id&apos;, PRIMARY KEY (`id`), KEY `index2_groupuu_user_id` (`user_id`) USING BTREE, KEY `index2_groupuu_ole_id` (`role_id`) USING BTREE, KEY `index2_groupuu_useridandroleid` (`user_id`,`role_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC; shiro相关]]></content>
      <tags>
        <tag>springboot</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装并使用Nexus3]]></title>
    <url>%2F2019%2F12%2F03%2Fdocker%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8Nexus3%2F</url>
    <content type="text"><![CDATA[安装拉取nexus3镜像1docker pull docker.io/sonatype/nexus3 运行nexus容器docker run -d -p 8081:8081 --restart=always --name nexus -v nexus-data:/home/nexus sonatype/docker-nexus3 1234567注释：docker run -d ##后台启动 -p 8081:8081 ##映射端口：容器端口--restart=always ##容器重启策略--name nexus ##容器命名-v nexus-data:/home/nexus ##数据挂载到 /home/nexus 例如nexus下载包放入宿主机该位置sonatype/docker-nexus3 ##指定nexus3镜像 浏览器访问http://ip:8081登录账号：admin登录密码：admin123]]></content>
      <tags>
        <tag>Nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java整型相除为0]]></title>
    <url>%2F2019%2F11%2F13%2Fjava%E6%95%B4%E5%9E%8B%E7%9B%B8%E9%99%A4%E4%B8%BA0%2F</url>
    <content type="text"><![CDATA[正确写法]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装zookeeper]]></title>
    <url>%2F2019%2F10%2F16%2Fdocker%E5%AE%89%E8%A3%85zookeeper%2F</url>
    <content type="text"><![CDATA[下载zookeeper镜像docker pull zookeeper 启动容器并添加映射docker run --privileged=true -d --name zookeeper --publish 2181:2181 -d zookeeper:latest 查看容器是否启动docker ps]]></content>
      <tags>
        <tag>docker</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos关闭防火墙]]></title>
    <url>%2F2019%2F10%2F16%2FCentos%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[查看防火墙是否开启1firewall-cmd --state 关闭防火墙systemctl stop firewalld.service 禁止firewall开机启动systemctl disable firewalld.service]]></content>
      <tags>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器开机自动启动]]></title>
    <url>%2F2019%2F10%2F16%2FDocker%E5%AE%B9%E5%99%A8%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[前言 部署项目服务器时，为了应对停电等情况影响正常web项目的访问，会把Docker容器设置为开机自动启动。 初次运行容器 使用–restart参数来设置 12docker run -m 512m --memory-swap 1G -it -p 58080:8080 --restart=always --name bvrfis --volumes-from logdata mytomcat:4.0 /root/run.sh restart具体参数值详细信息： no - 容器退出时，不重启容器； on-failure - 只有在非0状态退出时才从新启动容器； always - 无论退出状态是如何，都重启容器； 创建时未指定 –restart=always可通过update 命令设置 1docker update --restart=always xxx]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装docker]]></title>
    <url>%2F2019%2F10%2F16%2FCentos7%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[前言Docker需求配置lunix内核，要求3.8以上centos7Docker是一个进程，一启动就两个进程，一个服务，一个守护进程。占用资源就非常少，启动速度非常快，1s。一台机器上vm，3到10个实例。docker 100到10000。 安装Docker安装工具包1sudo yum install -y yum-utils #安装工具包，缺少这些依赖将无法完成 执行结果如下 1234567891011Loaded plugins: fastestmirror, langpacksbase | 3.6 kB 00:00:00epel | 4.3 kB 00:00:00extras | 3.4 kB 00:00:00update | 3.4 kB 00:00:00(1/3): epel/7/x86_64/updateinfo | 797 kB 00:00:00(2/3): epel/7/x86_64/primary_db | 4.7 MB 00:00:00(3/3): update/7/x86_64/primary_db | 4.8 MB 00:00:00Loading mirror speeds from cached hostfilePackage yum-utils-1.1.31-40.el7.noarch already installed and latest versionNothing to do 设置远程仓库123456$sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo执行结果：Loaded plugins: fastestmirror, langpacksadding repo from: https://download.docker.com/linux/centos/docker-ce.repograbbing file https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.reporepo saved to /etc/yum.repos.d/docker-ce.repo 安装1yum install docker-io 启动12345$ sudo systemctl start docker或者$ sudo service docker startservice docker start #启动dockerchkconfig docker on #加入开机启动 查看Docker版本123docker --help #帮助docker –v #简单查看版本docker version #查看版本]]></content>
      <tags>
        <tag>docker</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows安裝VMware]]></title>
    <url>%2F2019%2F10%2F16%2Fwindows%E5%AE%89%E8%A3%9DVMware%2F</url>
    <content type="text"><![CDATA[安装VMware12 傻瓜式安装！忽略 安装Centos7右击刚创建的虚拟机，选择设置进入阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/，选择 CentOS-7-x86_64-DVD-1804.iso下载 点击开启此虚拟机执行常规安装操作 桥接模式下设置固定ip1vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改如下 1234ONBOOT=yes # 该网卡是否随网络服务启动IPADDR=192.168.220.101 # 该网卡ip地址就是你要配置的固定IP，如果你要用xshell等工具连接，220这个网段最好和你自己的电脑网段一致，否则有可能用xshell连接失败GATEWAY=192.168.220.2 # 网关NETMASK=255.255.255.0 # 子网掩码 重启网络服务service network restart输入ifconfig显示如下代表成功]]></content>
      <tags>
        <tag>Centos</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis常见问题汇总]]></title>
    <url>%2F2019%2F10%2F15%2Fredis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[服务没有及时响应启动或控制请求redis.windows.conf配置文件存在空格，去除空格即可。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stackoverflow访问过慢]]></title>
    <url>%2F2019%2F10%2F11%2Fstackoverflow%E8%AE%BF%E9%97%AE%E8%BF%87%E6%85%A2%2F</url>
    <content type="text"><![CDATA[介绍 stackoverflow是开发常用的提问和解决代码问题网站，但自己访问总是非常的慢，几十秒甚至几分钟。 网站：https://stackoverflow.com/ 分析墙太厚 stackoverflow只是访问速度很慢，但终归可以打开，如果被墙不可能最后打开的，所以排除。 请求阻塞 访问jquery.min.js资源阻塞。 host添加一下 1127.0.0.1 ajax.googleapis.com]]></content>
      <tags>
        <tag>论坛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[double转integer]]></title>
    <url>%2F2019%2F09%2F28%2Fdouble%E8%BD%ACinteger%2F</url>
    <content type="text"><![CDATA[（1）把double先转化成int类型 12Double reseve3=Double.parseDouble(bddet[0].getReserve3());int b=reseve3.intValue(); （2）再把int类型转化为Integer类型 1Integer rentCount=Integer.valueOf(b);]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[琦玉锻炼法]]></title>
    <url>%2F2019%2F09%2F09%2F%E7%90%A6%E7%8E%89%E9%94%BB%E7%82%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[琦玉老师锻炼法每天坚持100个仰卧起坐，100个俯卧撑，100个蹲下起立，还有10公里的长跑。 改进版每天坚持30个仰卧起坐，30个俯卧撑，30个蹲下起立，还有2公里的短跑。]]></content>
      <tags>
        <tag>锻炼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用工具]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[工具 说明 官网 IDEA 开发IDE https://www.jetbrains.com/idea/download Robomongo mongo客户端连接工具 https://robomongo.org/download SwitchHosts 本地host管理 https://oldj.github.io/SwitchHosts/ PowerDesigner 数据库设计工具 http://powerdesigner.de/ Axure 原型设计工具 https://www.axure.com/ MindMaster 思维导图设计工具 http://www.edrawsoft.cn/mindmaster ScreenToGif gif录制工具 https://www.screentogif.com/ ProcessOn 流程图绘制工具 https://www.processon.com/ PicPick 屏幕取色工具 https://picpick.app/zh/ draw.io 绘图 https://www.draw.io/ logomakr Logo https://logomakr.com/ PicGo 图床 https://github.com/Molunerfinn/PicGo/releases Typora markdown工具 https://www.typora.io/ finalShell 远程工具 http://www.hostbuf.com/]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PhantomJSDriver自动生成echart图片]]></title>
    <url>%2F2019%2F08%2F29%2FPhantomJSDriver%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90echart%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.codeborne&lt;/groupId&gt; &lt;artifactId&gt;phantomjsdriver&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;xml-apis&lt;/groupId&gt; &lt;artifactId&gt;xml-apis&lt;/artifactId&gt; &lt;version&gt;1.4.01&lt;/version&gt;&lt;/dependency&gt; 公共方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136import com.pexetech.core.util.EmptyUtils;import com.pexetech.core.util.PropertiesFileUtil;import org.openqa.selenium.JavascriptExecutor;import org.openqa.selenium.phantomjs.PhantomJSDriver;import org.openqa.selenium.phantomjs.PhantomJSDriverService;import org.openqa.selenium.remote.DesiredCapabilities;import sun.misc.BASE64Decoder;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream;import java.net.URLDecoder;import java.net.URLEncoder;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeUnit;/** * describe: saveSurfModelUrlToImgUtil * * @author zj * @date 2019/05/23 */public class PhantomJSDriverUtil &#123; /** * @param surfData echart所需数据 * @param basePath 访问路径 * @param telPath 模板路径 * @param code 存储路径 * @return */ public static String saveSurfModelUrlToImg(String surfData,String basePath,String telPath,String code) &#123; List&lt;String&gt; imageBase64List = new ArrayList&lt;String&gt;(); PhantomJSDriver driver=getPhantomJSDriver(); // 让浏览器访问空间主页 driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); driver.get(basePath+telPath); JavascriptExecutor js = (JavascriptExecutor) driver; //设置surf数据到页面 driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); //展示echarts js.executeScript("showImg("+surfData+")"); //加入一段休眠时间，防止js执行没完成就进行的 读取echart图片数据的功能。 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //获取echart图片数据 driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); String phTxt=(String) js.executeScript("return returnEchartImg(rhEcharts)"); //imageBase64放到list中 imageBase64List.add(phTxt.replace("data:image/png;base64,","")); //获取图片存储路径 String imgName = System.currentTimeMillis()+".png"; String imgpath =""; String osname = System.getProperties().getProperty("os.name"); //判断系统的环境win or Linux if (osname.equals("Linux")) &#123; imgpath = PropertiesFileUtil.getInstance().get("fileRoot"); &#125;else&#123; imgpath = "D:\\fileRoot"; &#125; String imgFilePath = imgpath+File.separator+code+ File.separator+imgName; Base64ToImage(phTxt.replace("data:image/png;base64,",""),imgFilePath,imgpath+File.separator+code); driver.close(); driver.quit(); imgFilePath = basePath+"/showPicture/detail?imgFile="+URLEncoder.encode(imgFilePath); return imgFilePath; &#125; private static PhantomJSDriver getPhantomJSDriver() &#123; //设置必要参数 DesiredCapabilities dcaps = new DesiredCapabilities(); //ssl证书支持 dcaps.setCapability("acceptSslCerts", true); //截屏支持 dcaps.setCapability("takesScreenshot", true); //css搜索支持 dcaps.setCapability("cssSelectorsEnabled", true); //js支持 dcaps.setJavascriptEnabled(true); //驱动支持 String osname = System.getProperties().getProperty("os.name"); //判断系统的环境win or Linux if (osname.equals("Linux")) &#123; dcaps.setCapability(PhantomJSDriverService.PHANTOMJS_EXECUTABLE_PATH_PROPERTY,"/usr/bin/phantomjs"); &#125; else &#123; dcaps.setCapability(PhantomJSDriverService.PHANTOMJS_EXECUTABLE_PATH_PROPERTY,"D:\\phantomjs-2.1.1-windows\\bin\\phantomjs.exe"); &#125; //创建无界面浏览器对象 PhantomJSDriver driver = new PhantomJSDriver(dcaps); return driver; &#125; /** * base64字符串转换成图片 * @param imgStr base64字符串 * @param imgFilePath 图片存放路径 * @return */ public static boolean Base64ToImage(String imgStr,String imgFilePath,String savePth) &#123; // 对字节数组字符串进行Base64解码并生成图片 // 图像数据为空 if (EmptyUtils.isEmpty(imgStr))&#123; return false; &#125; File saveFile = new File(savePth); if (!saveFile.exists())&#123; saveFile.mkdirs(); &#125; BASE64Decoder decoder = new BASE64Decoder(); try &#123; // Base64解码 byte[] b = decoder.decodeBuffer(imgStr); for (int i = 0; i &lt; b.length; ++i) &#123; // 调整异常数据 if (b[i] &lt; 0) &#123; b[i] += 256; &#125; &#125; OutputStream out = new FileOutputStream(imgFilePath); out.write(b); out.flush(); out.close(); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125;&#125; html写法123function returnEchartImg(echartObj) &#123; return echartObj.getDataURL(); &#125; 问题汇总echart图片在outlook客户端查看是显示黑底option 缺少 backgroundColor:&#39;#FFFFFF&#39;,]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>PhantomJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native 0.42 整合极光推送]]></title>
    <url>%2F2019%2F08%2F29%2Freact-native%E6%95%B4%E5%90%88%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[极光推送官网注册应用 配置jpush-react-nativegithub地址：https://github.com/jpush/jpush-react-native同样的，打开终端在项目根目录下输入： 12npm install jcore-react-native@1.0.0 --savenpm install jpush-react-native@1.5.0 --save 下载完成后，按1、2、3的顺序修改如下文件： 在1中修改如下：1234include ':jpush-react-native'project(':jpush-react-native').projectDir = new File(rootProject.projectDir, '../node_modules/jpush-react-native/android')include ':jcore-react-native'project(':jcore-react-native').projectDir = new File(rootProject.projectDir, '../node_modules/jcore-react-native/android') 在2中修改如下：1234567891011121314151617android &#123; defaultConfig &#123; applicationId &quot;yourApplicationId&quot; //就是在极光注册的包名 ... manifestPlaceholders = [ JPUSH_APPKEY: &quot;yourAppKey&quot;, //在此替换你的APPKey APP_CHANNEL: &quot;developer-default&quot; //应用渠道号 ] &#125;&#125;...dependencies &#123; compile fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;]) compile project(&apos;:jpush-react-native&apos;) compile project(&apos;:jcore-react-native&apos;) compile &quot;com.facebook.react:react-native:+&quot; // From node_modules&#125; 在3中修改如下：12345678910111213&lt;!--添加通知权限，$&#123;ApplicationID&#125;替换成你的applicationID!--&gt; &lt;premission android:name=&quot;$&#123;ApplicationID&#125;.permission.JPUSH_MESSAGE&quot; android:protectionLevel=&quot;signature&quot;/&gt; &lt;application ... &gt; ... &lt;!-- Required . Enable it you can get statistics data with channel --&gt; &lt;meta-data android:name=&quot;JPUSH_CHANNEL&quot; android:value=&quot;$&#123;APP_CHANNEL&#125;&quot;/&gt; &lt;meta-data android:name=&quot;JPUSH_APPKEY&quot; android:value=&quot;$&#123;JPUSH_APPKEY&#125;&quot;/&gt; &lt;/application&gt; 打开MainApplication.java，修改如下：1234567@Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new JPushPackage(false,false) ); &#125;]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成二维码]]></title>
    <url>%2F2019%2F08%2F29%2F%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[所需依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import java.awt.Graphics2D;import java.awt.Image;import java.awt.RenderingHints;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.OutputStream;import java.util.HashMap;import java.util.Map;import javax.imageio.ImageIO;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.WriterException;import com.google.zxing.common.BitMatrix;/** * 二维码工具类 * */public class QrCodeUtil&#123; private static final int BLACK = 0xFF000000; private static final int WHITE = 0xFFFFFFFF; /** * 生成二维码图片 * @param content 内容 * @param width 二维码图片宽度 如果有logo图片,不应低于250 * @param height 二维码图片高度 如果有logo图片,不应低于250 * @param logo 二维码上面的logo 可选 * @return 二维码图片 */ public static BufferedImage toBufferedImage(String content,int width,int height,Image logo) &#123; MultiFormatWriter multiFormatWriter = new MultiFormatWriter(); Map&lt;EncodeHintType, String&gt; hints = new HashMap&lt;&gt;(); //内容所使用编码 hints.put(EncodeHintType.CHARACTER_SET, "UTF-8"); BitMatrix matrix =null; try &#123; matrix = multiFormatWriter.encode(content,BarcodeFormat.QR_CODE, width, height, hints); &#125; catch (WriterException e) &#123; e.printStackTrace(); &#125; if(matrix == null)&#123;return null;&#125; BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; width; x++) &#123; for (int y = 0; y &lt; height; y++) &#123; image.setRGB(x, y, matrix.get(x, y) ? BLACK : WHITE); &#125; &#125; //二维码上面添加logo if(logo!=null)&#123; //缩小logo大小 构建图片流 BufferedImage tag = new BufferedImage(33, 33, BufferedImage.TYPE_INT_RGB); //绘制改变尺寸后的图 tag.getGraphics().drawImage(logo, 0, 0, 33, 33, null); Graphics2D g = image.createGraphics(); //画笔对象 // 设置对线段的锯齿状边缘处理 g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR); g.drawImage(logo, (width-tag.getWidth(null))/2, (height-tag.getHeight(null))/2, tag.getWidth(null), tag.getHeight(null), null); g.dispose(); &#125; return image; &#125; /** * 生成二维码,并保存为文件 * @param content 二维码包含的内容 * @param width 二维码图片宽度 如果有logo图片,不应低于250 * @param height 二维码图片高度 如果有logo图片,不应低于250 * @param format 生成二维码图片的扩展名 如jpg/png等 * @param file 二维码保存文件 * @param logo logo图片 可选 */ public static void writeToFile(String content,int width,int height,String format,File file,Image logo)&#123; BufferedImage image = toBufferedImage(content,width,height,logo); try &#123; ImageIO.write(image, format, file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 生成二维码,并写到流中 * @param content 二维码包含的内容 * @param width 二维码图片宽度 如果有logo图片,不应低于250 * @param height 二维码图片高度 如果有logo图片,不应低于250 * @param format 生成二维码图片的扩展名 如jpg/png等 * @param stream 输出流 * @param logo logo图片 可选 */ public static void writeToStream(String content,int width,int height, String format,OutputStream outPutstream,Image logo) &#123; BufferedImage image = toBufferedImage(content,width,height,logo); try &#123; ImageIO.write(image, format, outPutstream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 调用实例123456789101112public static void main(String[] args) &#123; try &#123; String content = &quot;http://gys.zjtcn.com/project/detail/SZLHXQ22_gcxx_t_current_p1.html&quot;; //二维码保存位置 File outputFile = new File(&quot;d:/14.jpg&quot;); writeToFile(content, 250,250,&quot;png&quot;,outputFile,ImageIO.read(new File(&quot;D:/qrcode_logo.png&quot;))); writeToStream(content, 250, 250, &quot;png&quot;, System.out, ImageIO.read(new File(&quot;D:/qrcode_logo.png&quot;))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA学习记录]]></title>
    <url>%2F2019%2F08%2F17%2FJAVA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webService实战]]></title>
    <url>%2F2019%2F08%2F10%2FwebService%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[所需依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-discovery&lt;/groupId&gt; &lt;artifactId&gt;commons-discovery&lt;/artifactId&gt; &lt;version&gt;0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ws.xmlschema&lt;/groupId&gt; &lt;artifactId&gt;xmlschema-core&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.axis&lt;/groupId&gt; &lt;artifactId&gt;axis&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;3.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;3.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt; &lt;version&gt;3.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml&lt;/groupId&gt; &lt;artifactId&gt;jaxrpc-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; 定义实体、公共方法 model1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.List;/** * Project:&lt;记录接口传送结果或内容&gt; * * Comments:&lt;&gt; * * * @see * @param &lt;T&gt; */public class RealtechMiot&lt;T&gt; &#123; private WSRequest wsRequest; private WSResult wsResult; private List&lt;T&gt; datas; public RealtechMiot() &#123; &#125; public RealtechMiot(WSRequest wsRequest, List&lt;T&gt; datas) &#123; this.wsRequest = wsRequest; this.datas = datas; &#125; public RealtechMiot(WSResult wsResult, List&lt;T&gt; datas) &#123; this.wsResult = wsResult; this.datas = datas; &#125; public WSRequest getWsRequest() &#123; return this.wsRequest; &#125; public void setWsRequest(WSRequest wsRequest) &#123; this.wsRequest = wsRequest; &#125; public WSResult getWsResult() &#123; return this.wsResult; &#125; public void setWsResult(WSResult wsResult) &#123; this.wsResult = wsResult; &#125; public List&lt;T&gt; getDatas() &#123; return this.datas; &#125; public void setDatas(List&lt;T&gt; datas) &#123; this.datas = datas; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.thoughtworks.xstream.annotations.XStreamAlias;/** * Project:&lt;接口&gt; * &lt;p&gt; * Comments:&lt;用来传送信息&gt; * &lt;p&gt; * * @see */@XStreamAlias("head")public class WSRequest &#123; public WSRequest() &#123; &#125; public WSRequest(String function_id) &#123; this.function_id = function_id; &#125; public WSRequest(String function_id, String version) &#123; this.function_id = function_id; this.version = version; &#125; @XStreamAlias("function_id") private String function_id;// 方法名 private String version;// 方法版本 public String getFunction_id() &#123; return this.function_id; &#125; public void setFunction_id(String function_id) &#123; this.function_id = function_id; &#125; public String getVersion() &#123; return this.version; &#125; public void setVersion(String version) &#123; this.version = version; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.thoughtworks.xstream.annotations.XStreamAlias;/** * Project:&lt;接口&gt; * &lt;p&gt; * Comments:&lt;用来记录接口返回的结果&gt; * &lt;p&gt; */@XStreamAlias("head")public class WSResult &#123; public WSResult() &#123; &#125; public WSResult(boolean success, String code) &#123; this.success = success; this.code = code; &#125; public WSResult(boolean success, String code, String msg) &#123; this.success = success; this.msg = msg; this.code = code; &#125; private boolean success; private String msg; private String code; public boolean isSuccess() &#123; return success; &#125; public void setSuccess(boolean success) &#123; this.success = success; &#125; public String getMsg() &#123; return this.msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public String getCode() &#123; return this.code; &#125; public void setCode(String code) &#123; this.code = code; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Project:&lt;接口&gt; * * Comments:&lt;用来记录接口返回的结果&gt; * * * @see data 一般为一个json或jsonArrayList */public class XmlResult &#123; private boolean success; private String msg; private Object data; private String errorCode; public XmlResult() &#123; &#125; public XmlResult(boolean success, String msg, Object data, String errorCode) &#123; this.success = success; this.msg = msg; this.data = data; this.errorCode = errorCode; &#125; public XmlResult(boolean success, String msg) &#123; super(); this.success = success; this.msg = msg; &#125; public XmlResult(boolean success, String msg, Object data) &#123; super(); this.success = success; this.msg = msg; this.data = data; &#125; public boolean isSuccess() &#123; return success; &#125; public void setSuccess(boolean success) &#123; this.success = success; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; public String getErrorCode() &#123; return errorCode; &#125; public void setErrorCode(String errorCode) &#123; this.errorCode = errorCode; &#125;&#125; util123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerConfigurationException;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.*;import java.util.Properties;public class DOMUtils &#123; /** * 初始化一个空Document对象返回。 * * @return a Document */ public static Document newXMLDocument() &#123; try &#123; return newDocumentBuilder().newDocument(); &#125; catch (ParserConfigurationException e) &#123; throw new RuntimeException(e.getMessage()); &#125; &#125; /** * 初始化一个DocumentBuilder * * @return a DocumentBuilder * @throws ParserConfigurationException */ public static DocumentBuilder newDocumentBuilder() throws ParserConfigurationException &#123; return newDocumentBuilderFactory().newDocumentBuilder(); &#125; /** * 初始化一个DocumentBuilderFactory * * @return a DocumentBuilderFactory */ public static DocumentBuilderFactory newDocumentBuilderFactory() &#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setNamespaceAware(true); return dbf; &#125; /** * 将传入的一个XML String转换成一个org.w3c.dom.Document对象返回。 * * @param xmlString * 一个符合XML规范的字符串表达。 * @return a Document */ public static Document parseXMLDocument(String xmlString) &#123; if (xmlString == null) &#123; throw new IllegalArgumentException(); &#125; try &#123; return newDocumentBuilder().parse( new InputSource(new StringReader(xmlString))); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage()); &#125; &#125; /** * 给定一个输入流，解析为一个org.w3c.dom.Document对象返回。 * * @param input * @return a org.w3c.dom.Document */ public static Document parseXMLDocument(InputStream input) &#123; if (input == null) &#123; throw new IllegalArgumentException("参数为null！"); &#125; try &#123; return newDocumentBuilder().parse(input); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage()); &#125; &#125; /** * 给定一个文件名，获取该文件并解析为一个org.w3c.dom.Document对象返回。 * * @param fileName * 待解析文件的文件名 * @return a org.w3c.dom.Document */ public static Document loadXMLDocumentFromFile(String fileName) &#123; if (fileName == null) &#123; throw new IllegalArgumentException("未指定文件名及其物理路径！"); &#125; try &#123; return newDocumentBuilder().parse(new File(fileName)); &#125; catch (SAXException e) &#123; throw new IllegalArgumentException("目标文件（" + fileName + "）不能被正确解析为XML！" + e.getMessage()); &#125; catch (IOException e) &#123; throw new IllegalArgumentException("不能获取目标文件（" + fileName + "）！" + e.getMessage()); &#125; catch (ParserConfigurationException e) &#123; throw new RuntimeException(e.getMessage()); &#125; &#125; /* * 把dom文件转换为xml字符串 */ public static String toStringFromDoc(Document document) &#123; String result = null; if (document != null) &#123; StringWriter strWtr = new StringWriter(); StreamResult strResult = new StreamResult(strWtr); TransformerFactory tfac = TransformerFactory.newInstance(); try &#123; Transformer t = tfac.newTransformer(); t.setOutputProperty(OutputKeys.ENCODING, "UTF-8"); t.setOutputProperty(OutputKeys.INDENT, "yes"); t.setOutputProperty(OutputKeys.METHOD, "xml"); // xml, html, // text t.setOutputProperty( "&#123;http://xml.apache.org/xslt&#125;indent-amount", "4"); t.transform(new DOMSource(document.getDocumentElement()), strResult); &#125; catch (Exception e) &#123; System.err.println("XML.toString(Document): " + e); &#125; result = strResult.getWriter().toString(); try &#123; strWtr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125; /* * 把dom文件转换为xml字符串 */ public static String toStringFromDoc(Element element) &#123; String result = null; if (element != null) &#123; StringWriter strWtr = new StringWriter(); StreamResult strResult = new StreamResult(strWtr); TransformerFactory tfac = TransformerFactory.newInstance(); try &#123; Transformer t = tfac.newTransformer(); t.setOutputProperty(OutputKeys.ENCODING, "UTF-8"); t.setOutputProperty(OutputKeys.INDENT, "yes"); t.setOutputProperty(OutputKeys.METHOD, "xml"); // xml, html, // text t.setOutputProperty( "&#123;http://xml.apache.org/xslt&#125;indent-amount", "4"); t.transform(new DOMSource(element), strResult); &#125; catch (Exception e) &#123; System.err.println("XML.toString(Document): " + e); &#125; result = strResult.getWriter().toString(); try &#123; strWtr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125; /** * 给定一个节点，将该节点加入新构造的Document中。 * * @param node * a Document node * @return a new Document */ public static Document newXMLDocument(Node node) &#123; Document doc = newXMLDocument(); doc.appendChild(doc.importNode(node, true)); return doc; &#125; /** * 将传入的一个DOM Node对象输出成字符串。如果失败则返回一个空字符串""。 * * @param node * DOM Node 对象。 * @return a XML String from node */ /* * public static String toString(Node node) &#123; if (node == null) &#123; throw new * IllegalArgumentException(); &#125; Transformer transformer = new * Transformer(); if (transformer != null) &#123; try &#123; StringWriter sw = new * StringWriter(); transformer .transform(new DOMSource(node), new * StreamResult(sw)); return sw.toString(); &#125; catch (TransformerException * te) &#123; throw new RuntimeException(te.getMessage()); &#125; &#125; return ""; &#125; */ /** * 将传入的一个DOM Node对象输出成字符串。如果失败则返回一个空字符串""。 * * @param node * DOM Node 对象。 * @return a XML String from node */ /* * public static String toString(Node node) &#123; if (node == null) &#123; throw new * IllegalArgumentException(); &#125; Transformer transformer = new * Transformer(); if (transformer != null) &#123; try &#123; StringWriter sw = new * StringWriter(); transformer .transform(new DOMSource(node), new * StreamResult(sw)); return sw.toString(); &#125; catch (TransformerException * te) &#123; throw new RuntimeException(te.getMessage()); &#125; &#125; return ""; &#125; */ /** * 获取一个Transformer对象，由于使用时都做相同的初始化，所以提取出来作为公共方法。 * * @return a Transformer encoding gb2312 */ public static Transformer newTransformer() &#123; try &#123; Transformer transformer = TransformerFactory.newInstance() .newTransformer(); Properties properties = transformer.getOutputProperties(); properties.setProperty(OutputKeys.ENCODING, "gb2312"); properties.setProperty(OutputKeys.METHOD, "xml"); properties.setProperty(OutputKeys.VERSION, "1.0"); properties.setProperty(OutputKeys.INDENT, "no"); transformer.setOutputProperties(properties); return transformer; &#125; catch (TransformerConfigurationException tce) &#123; throw new RuntimeException(tce.getMessage()); &#125; &#125; /** * 返回一段XML表述的错误信息。提示信息的TITLE为：系统错误。之所以使用字符串拼装，主要是这样做一般 不会有异常出现。 * * @param errMsg * 提示错误信息 * @return a XML String show err msg */ /* * public static String errXMLString(String errMsg) &#123; StringBuffer msg = new * StringBuffer(100); * msg.append("&lt;?xml version="1.0" encoding="gb2312" ?&gt;"); * msg.append("&lt;errNode title="系统错误" errMsg="" + errMsg + ""/&gt;"); return * msg.toString(); &#125; */ /** * 返回一段XML表述的错误信息。提示信息的TITLE为：系统错误 * * @param errMsg * 提示错误信息 * @param errClass * 抛出该错误的类，用于提取错误来源信息。 * @return a XML String show err msg */ /* * public static String errXMLString(String errMsg, Class errClass) &#123; * StringBuffer msg = new StringBuffer(100); * msg.append("&lt;?xml version='1.0' encoding='gb2312' ?&gt;"); * msg.append("&lt;errNode title=" * 系统错误" errMsg=""+ errMsg + "" errSource=""+ errClass.getName()+ ""/&gt;"); * return msg.toString(); &#125; */ /** * 返回一段XML表述的错误信息。 * * @param title * 提示的title * @param errMsg * 提示错误信息 * @param errClass * 抛出该错误的类，用于提取错误来源信息。 * @return a XML String show err msg */ public static String errXMLString(String title, String errMsg, Class errClass) &#123; StringBuffer msg = new StringBuffer(100); msg.append("&lt;?xml version='1.0' encoding='utf-8' ?&gt;"); msg.append("&lt;errNode title=" + title + "errMsg=" + errMsg + "errSource=" + errClass.getName() + "/&gt;"); return msg.toString(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import com.pexetech.core.util.EmptyUtils;import com.pexetech.core.util.PropertiesFileUtil;import com.pexetech.rest.common.model.WSResult;import org.apache.axis.client.Call;import org.apache.axis.client.Service;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import javax.xml.namespace.QName;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import java.io.IOException;import java.io.StringReader;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.List;public class XmlOperationUtil&lt;T&gt; &#123; protected final Log _log = LogFactory.getLog(getClass()); private final String PATTERN = "yyyy-MM-dd HH:mm:ss"; private final SimpleDateFormat FORMAT = new SimpleDateFormat(PATTERN); public List&lt;T&gt; getTByname(Class&lt;T&gt; cls, NodeList nodeList) &#123; List&lt;T&gt; tList = new ArrayList&lt;T&gt;(); for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; Element ele = (Element) nodeList.item(i); T t = XmlUtil.toBean(DOMUtils.toStringFromDoc(ele), cls); tList.add(t); &#125; return tList; &#125; public Element getElerootByTagName(String xml, String tagName) &#123; NodeList bomNodeList = getElerootsByTagName(xml, tagName); Element bomRoot = (Element) bomNodeList.item(0); return bomRoot; &#125; public NodeList getElerootsByTagName(String xml, String tagName) &#123; if (EmptyUtils.isBlank(xml)) &#123; return null; &#125; Document document = createDocument(xml); return document.getElementsByTagName(tagName); &#125; public WSResult createErrWSResult() &#123; WSResult r = new WSResult(); r.setCode("-100"); r.setMsg("系统出现异常！"); return r; &#125; public Document createDocument(String xml) &#123; try &#123; DocumentBuilderFactory factory = DocumentBuilderFactory .newInstance(); DocumentBuilder builder; builder = factory.newDocumentBuilder(); if (EmptyUtils.isBlank(xml)) &#123; return null; &#125; StringReader sr = new StringReader(xml); InputSource is = new InputSource(sr); return builder.parse(is); &#125; catch (SAXException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ParserConfigurationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125; public String callWebService(String xml, String method) &#123; try &#123; // 指出service所在完整的URL String endpoint = PropertiesFileUtil.getInstance("api").get("webservicePath"); //调用接口的targetNamespace String targetNamespace = "http://webservice.web.rest.pexetech.com/"; //所调用接口的方法method method = method == null ? PropertiesFileUtil.getInstance("api").get("methodName") : method; //以上需要配置 _log.info("发送信息：" + xml); // 创建一个服务(service)调用(call) Service service = new Service();// javax.xml.rpc.Call call= service.createCall(); Call call = (Call) service.createCall();// 通过service创建call对象 // 设置service所在URL call.setTargetEndpointAddress(new java.net.URL(endpoint)); call.setOperationName(new QName(targetNamespace, method)); call.setUseSOAPAction(true); //变量最好只是用String类型，其他类型会报错 call.addParameter(new QName(targetNamespace, "xml"), org.apache.axis.encoding.XMLType.XSD_STRING, javax.xml.rpc.ParameterMode.IN);//设置参数名 state 第二个参数表示String类型,第三个参数表示入参 call.setReturnType(org.apache.axis.encoding.XMLType.XSD_STRING);// 设置返回类型 // String path = targetNamespace + method; // call.setSOAPActionURI(path); String jsonString = (String) call.invoke(new Object[]&#123;xml&#125;);//此处为数组，有几个变量传几个变量// //将json字符串转换为JSON对象// JSON json = (JSON) JSON.parse(jsonString);// //将接送对象转为java对象,此处用object代替，用的时候转换为你需要是用的对象就行了// Object object = JSON.toJavaObject(json, Object.class);//注意别到错包com.alibaba.fastjson.JSON _log.info("返回结果：" + jsonString); return jsonString; &#125; catch (Exception e) &#123; _log.error("callWebService error ", e); &#125; return null; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.io.xml.DomDriver;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import java.io.IOException;import java.io.StringReader;/** * 输出xml和解析xml的工具类 * * @ClassName:XmlUtil * @author: chenyoulong Email: chen.youlong@payeco.com * @date :2012-9-29 上午9:51:28 * @Description:TODO */public class XmlUtil &#123; /** * java 转换成xml * * @param obj 对象实例 * @return String xml字符串 * @Title: toXml * @Description: TODO */ public static String toXml(Object obj) &#123; XStream xstream = new XStream(); XStream.setupDefaultSecurity(xstream); xstream.allowTypes(new Class[]&#123;XmlUtil.class&#125;); // XStream xstream=new XStream(new DomDriver()); //直接用jaxp dom来解释 // XStream xstream=new XStream(new DomDriver("utf-8")); // //指定编码解析器,直接用jaxp dom来解释 // //如果没有这句，xml中的根元素会是&lt;包.类名&gt;；或者说：注解根本就没生效，所以的元素名就是类的属性 xstream.processAnnotations(obj.getClass()); // 通过注解方式的，一定要有这句话 return xstream.toXML(obj); &#125; /** * 将传入xml文本转换成Java对象 * * @param xmlStr * @param cls xml对应的class类 * @return T xml对应的class类的实例对象 * &lt;p&gt; * 调用的方法实例：PersonBean person=XmlUtil.toBean(xmlStr, * PersonBean.class); * @Title: toBean * @Description: TODO */ public static &lt;T&gt; T toBean(String xmlStr, Class&lt;T&gt; cls) &#123; // 注意：不是new Xstream(); 否则报错：java.lang.NoClassDefFoundError: // org/xmlpull/v1/XmlPullParserFactory XStream xstream = new XStream(new DomDriver()); xstream.processAnnotations(cls); T obj = (T) xstream.fromXML(xmlStr); return obj; &#125; public static NodeList getRootEleList(String bomXml, String rootName) &#123; Document document = createDocument(bomXml); NodeList bomNodeList = document.getElementsByTagName(rootName); return bomNodeList; &#125; public static Element getRootEle(String bomXml, String rootName) &#123; Document document = createDocument(bomXml); NodeList bomNodeList = document.getElementsByTagName(rootName); if (bomNodeList == null || bomNodeList.getLength() == 0) &#123; return null; &#125; Element bomRoot = (Element) bomNodeList.item(0); return bomRoot; &#125; public static String getRootEleValue(String bomXml, String rootName) &#123; Document document = createDocument(bomXml); NodeList bomNodeList = document.getElementsByTagName(rootName); if (bomNodeList == null || bomNodeList.getLength() == 0) &#123; return null; &#125; Element bomRoot = (Element) bomNodeList.item(0); return bomRoot.getTextContent(); &#125; // 返回根目录下元素的值 public static String getRootDocumentValue(String bomXml, String rootName) &#123; Document document = createDocument(bomXml); NodeList bomNodeList = document.getChildNodes(); for (int i = 0; i &lt; bomNodeList.getLength(); i++) &#123; Element bomRoot = (Element) bomNodeList.item(i); NodeList childrenNodeList = bomRoot.getChildNodes(); for (int j = 0; j &lt; childrenNodeList.getLength(); j++) &#123; if (childrenNodeList.item(j).hasChildNodes()) &#123; Element childrenRoot = (Element) childrenNodeList.item(j); if (rootName.equals(childrenRoot.getTagName())) &#123; return childrenRoot.getTextContent(); &#125; &#125; &#125; &#125; return null; &#125; public static String getRootEleValue(Element ele, String rootName) &#123; NodeList bomNodeList = ele.getElementsByTagName(rootName); if (bomNodeList == null || bomNodeList.getLength() == 0) &#123; return null; &#125; Element bomRoot = (Element) bomNodeList.item(0); return bomRoot.getTextContent(); &#125; public static Document createDocument(String xml) &#123; try &#123; DocumentBuilderFactory factory = DocumentBuilderFactory .newInstance(); DocumentBuilder builder; builder = factory.newDocumentBuilder(); StringReader sr = new StringReader(xml); InputSource is = new InputSource(sr); return builder.parse(is); &#125; catch (SAXException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ParserConfigurationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125;// public static XmlResult sendWebService(String command, String xml) &#123;// try &#123;// // Client c = new Client(new// // URL("http://wuxin20642.xicp.net:19845/services/myService?wsdl"));// Client c = new Client(new URL("http://127.0.0.1:7890/HelloWorld?wsdl"));// Object[] result = c.invoke(command, new String[]&#123;xml&#125;);// return new XmlResult(true, "call success.", (String) result[0]);// &#125; catch (ConnectException ce) &#123;// return new XmlResult(false, "call ConnectException.", null, "404");// &#125; catch (Exception e) &#123;// System.err.println(e.toString());// &#125;// return new XmlResult(false, "call error.", null, "500");// &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import com.pexetech.core.util.EmptyUtils;import com.pexetech.rest.common.model.RealtechMiot;import com.pexetech.rest.common.model.WSRequest;import com.pexetech.rest.common.model.WSResult;import org.w3c.dom.Element;import org.w3c.dom.NodeList;import java.util.List;public class XmlUtilForMiot&lt;T&gt; extends XmlOperationUtil&lt;T&gt; &#123; public static final String ROOT = "realtech"; public static final String BODY = "body"; public static final String HEAD = "head"; public static final String DATA = "data"; public RealtechMiot&lt;T&gt; toRequestBean(String xmlStr, Class&lt;T&gt; cls) &#123; Element rootEle = getRootEle(xmlStr); Element head = getElerootByTagName(DOMUtils.toStringFromDoc(rootEle), HEAD); WSRequest wsRequest = XmlUtil.toBean(DOMUtils.toStringFromDoc(head), WSRequest.class); List&lt;T&gt; tList = createTlist(cls, rootEle); RealtechMiot&lt;T&gt; tm = new RealtechMiot&lt;T&gt;(wsRequest, tList); return tm; &#125; private List&lt;T&gt; createTlist(Class&lt;T&gt; cls, Element rootEle) &#123; Element bodyEle = getBodyEle(DOMUtils.toStringFromDoc(rootEle)); List&lt;T&gt; tList = null; if (cls != null) &#123; NodeList nodeList = getElerootsByTagName( DOMUtils.toStringFromDoc(bodyEle), DATA); if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) &#123; tList = getTByname(cls, nodeList); &#125; &#125; return tList; &#125; public RealtechMiot&lt;T&gt; toResultBean(String xmlStr, Class&lt;T&gt; cls) &#123; Element rootEle = getRootEle(xmlStr); Element head = getElerootByTagName(DOMUtils.toStringFromDoc(rootEle), HEAD); WSResult wsResult = XmlUtil.toBean(DOMUtils.toStringFromDoc(head), WSResult.class); List&lt;T&gt; tList = createTlist(cls, rootEle); RealtechMiot&lt;T&gt; tm = new RealtechMiot&lt;T&gt;(wsResult, tList); return tm; &#125; public String toRequestXml(WSRequest wsRequest, List&lt;T&gt; datas) &#123; String head = XmlUtil.toXml(wsRequest); String dataStr = listToXmlStr(datas); String result = connectXmlStr(head, dataStr); return result; &#125; public String toRequestXml(WSRequest wsRequest, Object datas) &#123; String head = XmlUtil.toXml(wsRequest); String dataStr = listToXmlStr(datas); String result = connectXmlStr(head, dataStr); return result; &#125; public String toResultXml(WSResult wsResult, List&lt;T&gt; datas) &#123; try &#123; String head = XmlUtil.toXml(wsResult); String dataStr = listToXmlStr(datas); String result = connectXmlStr(head, dataStr); return result; &#125; catch (Exception e) &#123; String head = XmlUtil.toXml(createErrWSResult()); return connectXmlStr(head, null); &#125; &#125; private String connectXmlStr(String head, String dataStr) &#123; if (dataStr == null || EmptyUtils.isBlank(dataStr)) &#123; dataStr = "&lt;data&gt;&lt;/data&gt;"; &#125; String result = "&lt;" + ROOT + "&gt;" + head + "&lt;" + BODY + "&gt;" + dataStr + "&lt;/" + BODY + "&gt;" + "&lt;/" + ROOT + "&gt;"; // 处理xStreambug，一个"_"会变成2个 if (result.contains("__")) &#123; result = result.replace("__", "_"); &#125; return result; &#125; private String listToXmlStr(List&lt;T&gt; datas) &#123; String dataStr = ""; if (datas != null) &#123; for (T t : datas) &#123; dataStr += XmlUtil.toXml(t); &#125; &#125; return dataStr; &#125; private String listToXmlStr(Object datas) &#123; String dataStr = XmlUtil.toXml(datas); return dataStr; &#125; public Element getRootEle(String xml) &#123; return getElerootByTagName(xml, ROOT); &#125; public Element getBodyEle(String xml) &#123; return getElerootByTagName(xml, BODY); &#125;&#125; spring注入applicationContext-webservice.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd&quot;&gt; &lt;jaxws:endpoint id=&quot;pexeService&quot; implementor=&quot;com.pexetech.rest.web.webservice.PexeServiceImpl&quot; address=&quot;http://127.0.0.1:6789/webService&quot;/&gt; &lt;!--物料入库--&gt; &lt;bean id=&quot;create_material_input&quot; class=&quot;com.pexetech.rest.web.webservice.service.InventoryInputRestService&quot;&gt; &lt;property name=&quot;function&quot; value=&quot;createMaterialInput&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 工厂 123public interface WSFunctionFactory &#123; public String execute(String message);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import com.pexetech.core.util.EmptyUtils;import com.pexetech.rest.web.webservice.WSFunctionFactory;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import java.lang.reflect.InvocationTargetException;public abstract class WebService implements WSFunctionFactory &#123; protected final Log _log = LogFactory.getLog(getClass()); private String _function; private String _companyId = "c3457cb41baa4b568e05799751de33e4"; public String getCompanyId() &#123; return _companyId; &#125; public void setCompanyId(String companyId) &#123; this._companyId = companyId; &#125; public void setFunction(String function) &#123; this._function = function; &#125; public String getFunction() &#123; return this._function; &#125; public String executeMethod(String message) &#123; return null; &#125; public String execute(String message) &#123; String s = null; try &#123; if (!EmptyUtils.isBlank(getFunction())) &#123; s = (String) this.getClass() .getMethod(getFunction(), String.class) .invoke(this, message); &#125; else &#123; s = executeMethod(message); &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; return s; &#125;&#125; 提供者123456789public class CreateUnbomRequestRestService extends WebService &#123; private XmlUtilForMiot&lt;PurchaseUnbomRequestPXView&gt; iixml = new XmlUtilForMiot&lt;PurchaseUnbomRequestPXView&gt;(); public String createUnbomRequest(String msg) &#123; WSResult r = null; r = new WSResult(true, "100", "抛送成功"); return iixml.toResultXml(r, resultList); &#125; &#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>webService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis开机自启]]></title>
    <url>%2F2019%2F08%2F08%2Fredis%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%2F</url>
    <content type="text"><![CDATA[window1redis-server --service-install redis.windows.conf --loglevel verbose 1、安装service服务 redis-server –service-install redis.windows.conf –service-name redis63792、启动service服务 redis-server –service-start3、停止命令 redis-server –service-stop4、卸载命令 redis-server –service-uninstall –service-name redis6379 linux设置redis.conf中daemonize为yes,确保守护进程开启。 查找redis配置文件redis.conf 12[root@localhost /]# find / -name redis.conf/usr/local/redis/redis.conf 编辑redis配置文件 1[root@localhost ~]# vim /usr/local/redis/redis.conf 命令行模式下输入 /daemonize 查找,将配置文件中daemonize为yes 编写开机自启动脚本vi /etc/init.d/redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# chkconfig: 2345 10 90 # description: Start and Stop redis PATH=/usr/local/bin:/sbin:/usr/bin:/bin REDISPORT=6379 EXEC=/usr/local/redis/redis-server REDIS_CLI=/usr/local/redis/redis-cli PIDFILE=/var/run/redis.pid CONF=&quot;/usr/local/redis/redis.conf&quot;case &quot;$1&quot; in start) if [ -f $PIDFILE ] then echo &quot;$PIDFILE exists, process is already running or crashed.&quot; else echo &quot;Starting Redis server...&quot; $EXEC $CONF fi if [ &quot;$?&quot;=&quot;0&quot; ] then echo &quot;Redis is running...&quot; fi ;; stop) if [ ! -f $PIDFILE ] then echo &quot;$PIDFILE exists, process is not running.&quot; else PID=$(cat $PIDFILE) echo &quot;Stopping...&quot; $REDIS_CLI -p $REDISPORT SHUTDOWN sleep 2 while [ -x $PIDFILE ] do echo &quot;Waiting for Redis to shutdown...&quot; sleep 1 done echo &quot;Redis stopped&quot; fi ;; restart|force-reload) $&#123;0&#125; stop $&#123;0&#125; start ;; *) echo &quot;Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;&quot; &gt;&amp;2 exit 1 esac 设置权限1[root@localhost init.d]# chmod 777 /etc/init.d/redis]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置ssl证书]]></title>
    <url>%2F2019%2F08%2F08%2Fnginx%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[配置如下 123456789101112131415161718192021222324252627282930server &#123; listen 443; server_name sm.moldcio.com; # localhost修改为您证书绑定的域名。 #error_page 497 https://$host$request_uri; #正常错误反馈转换到https ssl on; #设置为on启用SSL功能。 #root html; #index index.html index.htm; ssl_certificate /tomcat/ssl_key/2225091_sm.moldcio.com.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key /tomcat/ssl_key/2225091_sm.moldcio.com.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://119.3.9.188; &#125; &#125; server &#123; listen 80; server_name sm.moldcio.com; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://119.3.9.188:8101; &#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker常用命令]]></title>
    <url>%2F2019%2F08%2F08%2Fdocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[docker logs 查看实时日志1docker logs -f -t --since=&quot;2019-01-12&quot; --tail=200 upms-web –since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志。 -f : 查看实时日志 -t : 查看日志产生的日期 -tail=10 : 查看最后的10条日志。 upms-web : 容器名称 进入tomcat容器 查看jdk版本123docker exec -it upms-web /bin/bashjava -version 重启指定容器1docker restart [容器名称] 查看挂载1docker inspect nginx docker 生成镜像1docker-compose up 复制日志1docker cp mes-web:/usr/local/logs/mes-web.log ~]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github常用命令]]></title>
    <url>%2F2019%2F08%2F08%2Fgithub%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看这个月star最多的项目12https://github.com/trending/java?since=monthly[java]可以替换成其他语言 常用命令git init 新建一个空的仓库git status 查看状态git add . 添加文件git commit -m ‘注释’ 提交添加的文件并备注说明git remote add origin git@github.com:jinzhaogit/git.git 连接远程仓库git push -u origin master 将本地仓库文件推送到远程仓库git log 查看变更日志git reset –hard 版本号前六位 回归到指定版本git branch 查看分支git branch newname 创建一个叫newname的分支git checkout newname 切换到叫newname的分支上git merge newname 把newname分支合并到当前分支上git pull origin master 将master分支上的内容拉到本地上]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdowm编辑以及图片上传]]></title>
    <url>%2F2019%2F08%2F08%2FMarkdowm%E7%BC%96%E8%BE%91%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[图片上传工具 PicGO 下载地址: https://github.com/Molunerfinn/PicGo/releases 配置PicGo markdown工具 Typora]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdowm</tag>
      </tags>
  </entry>
</search>
